name: Predict, Deploy & Autoâ€‘Heal Pipeline

on:
  workflow_dispatch:
  push:
    branches: ['*']

permissions:
  id-token: write
  contents: read

env:
  AWS_DEFAULT_REGION: "${{ secrets.AWS_DEFAULT_REGION }}"
  AWS_ACCOUNT_ID:     "${{ secrets.AWS_ACCOUNT_ID }}"
  ECR_REPO:           "${{ secrets.ECR_REPO }}"
  IMAGE_TAG:          "1.2-1-cpu-py3"
  MODEL_IMAGE_URI:    "709825985650.dkr.ecr.ap-southeast-2.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3"
  MODEL_S3_PATH:      "${{ secrets.MODEL_S3_PATH }}"

jobs:
  build-deploy-heal:
    runs-on: ubuntu-latest
    env:
      NS:     "${{ secrets.EKS_NAMESPACE        || 'prod' }}"
      DEPLOY: "${{ secrets.EKS_DEPLOYMENT_NAME  || 'my-api-deployment' }}"
      CTR:    "${{ secrets.EKS_CONTAINER_NAME   || 'api-container' }}"

    steps:
    - uses: actions/checkout@v3

    - uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: "${{ secrets.AWS_ROLE_ARN }}"
        aws-region:     "${{ env.AWS_DEFAULT_REGION }}"

    - name: Who am I?
      run: aws sts get-caller-identity

    - name: Ensure ECR repos
      run: |
        for repo in "$ECR_REPO" sklearn-inference ; do
          aws ecr describe-repositories --repository-names "$repo" ||
          aws ecr create-repository --repository-name "$repo"
        done

    - name: Build & push APP image
      env: { DOCKER_BUILDKIT: 1 }
      run: |
        docker build --platform linux/amd64 -t $ECR_REPO:${{ github.sha }} ./app
        docker tag  $ECR_REPO:${{ github.sha }} \
          $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO:${{ github.sha }}
        aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
          docker login -u AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
        docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO:${{ github.sha }}

    - name: Upload model artefact
      run: aws s3 cp ml_model/models/model.tar.gz "$MODEL_S3_PATH"

    - name: Install kubectl
      run: |
        curl -sSL https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl -o kubectl
        chmod +x kubectl && sudo mv kubectl /usr/local/bin

    - name: Configure kubeconfig
      run: |
        aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name "${{ secrets.EKS_CLUSTER_NAME }}"
        kubectl get nodes

    - name: Bootstrap objects once
      run: kubectl apply -f kubernetes/bootstrap.yaml || true

    - name: Rollout new image
      env:
        IMAGE_URI: "${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_DEFAULT_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${{ github.sha }}"
      run: |
        kubectl set image deployment/$DEPLOY $CTR=$IMAGE_URI -n $NS
        kubectl rollout status deployment/$DEPLOY -n $NS --timeout=180s

    - uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Python deps
      run: |
        if [[ -f requirements.txt ]]; then pip install -r requirements.txt; fi
        pip install requests

    # ---------- Collect live build & test metrics ----------
    - name: Collect build metrics
      id: metrics
      run: |
        #######################################################
        # 1) Measure build time for the alreadyâ€“built image
        #######################################################
        # Reâ€‘run docker build with cache to time accurately
        build_start=$(date +%s)
        docker build --platform linux/amd64 -t $ECR_REPO:test-timer ./app >/dev/null
        build_time=$(( $(date +%s) - build_start ))

        #######################################################
        # 2) Run unit tests & capture failures / pass rate
        #######################################################
        pytest -q | tee test.log || true
        failed=$(grep -oP '(?<= )[0-9]+(?= failed)' test.log || echo 0)
        passed=$(grep -oP '(?<= )[0-9]+(?= passed)' test.log || echo 0)
        total=$(( passed + failed ))
        if [ "$total" -eq 0 ]; then
          test_pass_rate=0
        else
          test_pass_rate=$(awk "BEGIN {printf \"%.2f\", $passed/$total}")
        fi

        #######################################################
        # 3) Average CPU usage during tests (quick sample)
        #######################################################
        cpu_usage=$(mpstat 1 5 | awk '/Average/ {printf("%.0f",100-$NF)}')

        #######################################################
        # 4) Assemble JSON and export
        #######################################################
        metrics_json=$(jq -n -c \
          --arg bt "$build_time" \
          --arg ec "$failed" \
          --arg cu "$cpu_usage" \
          --arg tpr "$test_pass_rate" \
          '{build_time:($bt|tonumber),error_count:($ec|tonumber),cpu_usage:($cu|tonumber),test_pass_rate:($tpr|tonumber)}')

        echo "Metrics â†’ $metrics_json"
        echo "json=$metrics_json" >> $GITHUB_OUTPUT
    # --------------------------------------------------------

    # ---------- Predict step (numeric output via --plain) ----------
    - name: Predict failure probability
      id: predict
      run: |
        prob=$(python ml_model/predict_failure.py --plain --input-json '${{ steps.metrics.outputs.json }}')
        echo "Predicted failure probability: $prob"
        echo "fail_prob=$prob" >> $GITHUB_OUTPUT
    # ----------------------------------------------------------------

    - name: Autoâ€‘heal if prob â‰¥ 0.75
      if: "${{ steps.predict.outputs.fail_prob != '' && fromJson(steps.predict.outputs.fail_prob) >= 0.75 }}"
      env:
        SLACK_WEBHOOK_URL: "${{ secrets.SLACK_WEBHOOK_URL }}"
      run: |
        python pipeline/scripts/smart_auto_heal.py --deployment $DEPLOY --namespace $NS --replicas 3
        curl -X POST -H 'Content-Type: application/json' \
             --data "{\"text\":\"ðŸš‘ Autoâ€‘heal triggered (fail_prob=${{ steps.predict.outputs.fail_prob }}).\"}" \
             "$SLACK_WEBHOOK_URL"
