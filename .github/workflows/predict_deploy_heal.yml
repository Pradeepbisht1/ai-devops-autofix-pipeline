name: Predict, Deploy & Auto-Heal Pipeline

on:
  workflow_dispatch:
  push:
    branches: ['*']

permissions:
  id-token: write
  contents: read

env:
  AWS_DEFAULT_REGION: "${{ secrets.AWS_DEFAULT_REGION }}"
  AWS_ACCOUNT_ID:     "${{ secrets.AWS_ACCOUNT_ID }}"
  ECR_REPO:           "${{ secrets.ECR_REPO }}"
  IMAGE_TAG:          "1.2-1-cpu-py3"
  MODEL_IMAGE_URI:    "709825985650.dkr.ecr.ap-southeast-2.amazonaws.com/sagemaker-scikit-learn:1.2-1-cpu-py3"
  MODEL_S3_PATH:      "${{ secrets.MODEL_S3_PATH }}"

jobs:
  build-deploy-heal:
    runs-on: ubuntu-latest
    env:
      NS:        "${{ secrets.EKS_NAMESPACE        || 'prod' }}"
      DEPLOY:    "${{ secrets.EKS_DEPLOYMENT_NAME  || 'my-api-deployment' }}"
      CTR:       "${{ secrets.EKS_CONTAINER_NAME   || 'api-container' }}"
      SVC:       "${{ secrets.EKS_SERVICE_NAME     || 'my-api-service' }}"
      PROM_NS:   "${{ secrets.PROM_NAMESPACE       || 'monitoring' }}"
      PROM_SVC:  "${{ secrets.PROM_SERVICE_NAME    || 'prometheus-kube-prometheus-prometheus' }}"

    steps:
      - uses: actions/checkout@v3

      - uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: "${{ secrets.AWS_ROLE_ARN }}"
          aws-region:     "${{ env.AWS_DEFAULT_REGION }}"

      - name: Who am I?
        run: aws sts get-caller-identity

      - name: Ensure ECR repos
        run: |
          for repo in "$ECR_REPO" sklearn-inference ; do
            aws ecr describe-repositories --repository-names "$repo" ||
            aws ecr create-repository --repository-name "$repo"
          done

      - name: Build & push APP image
        env: { DOCKER_BUILDKIT: 1 }
        run: |
          docker build --platform linux/amd64 -t $ECR_REPO:${{ github.sha }} ./app
          docker tag  $ECR_REPO:${{ github.sha }} \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO:${{ github.sha }}
          aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
            docker login -u AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO:${{ github.sha }}

      - name: Upload model artefact (optional)
        run: aws s3 cp ml_model/models/model.pkl "$MODEL_S3_PATH" || true

      - name: Install kubectl
        run: |
          curl -sSL https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl -o kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin

      - name: Configure kubeconfig (namespaced check)
        run: |
          aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name "${{ secrets.EKS_CLUSTER_NAME }}"
          kubectl -n $NS get deploy || kubectl -n $NS get pods || true
          kubectl auth can-i watch deployments -n $NS || true

      # Apply only namespaced app objects
      - name: Apply app manifests
        run: |
          kubectl -n $NS apply -f kubernetes/deployment.yaml
          kubectl -n $NS apply -f kubernetes/service.yaml

      - uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Python deps
        run: |
          if [[ -f requirements.txt ]]; then pip install -r requirements.txt; fi
          pip install requests pytest joblib scikit-learn

      - name: Export PYTHONPATH for model
        run: echo "PYTHONPATH=${{ github.workspace }}" >> $GITHUB_ENV

      - name: Install CLI tools (jq)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # ----------------- ROLLOUT FIRST -----------------
      - name: Set new image & wait (5m)
        env:
          IMAGE_URI: "${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_DEFAULT_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${{ github.sha }}"
        run: |
          set -euo pipefail
          kubectl -n $NS set image deployment/$DEPLOY $CTR=$IMAGE_URI
          kubectl -n $NS rollout status deployment/$DEPLOY --timeout=5m

      - name: Debug rollout failure
        if: failure()
        run: |
          set -euo pipefail
          echo "==== describe deploy ===="
          kubectl -n $NS describe deploy/$DEPLOY || true
          echo "==== rs (by selector) ===="
          kubectl -n $NS get rs -l app=$DEPLOY -o wide || true
          echo "==== pods ===="
          kubectl -n $NS get pods -l app=$DEPLOY -o wide || true
          echo "==== last 50 events ===="
          kubectl -n $NS get events --sort-by=.lastTimestamp | tail -n 50 || true
          echo "==== not-ready pod logs (first 100 lines) ===="
          for p in $(kubectl -n $NS get pods -l app=$DEPLOY -o jsonpath='{.items[*].metadata.name}'); do
            rdy=$(kubectl -n $NS get pod "$p" -o jsonpath='{.status.containerStatuses[0].ready}' 2>/dev/null || echo "false")
            if [ "$rdy" != "true" ]; then
              echo "--- $p ---"
              kubectl -n $NS logs "$p" --tail=100 || true
            fi
          done

      # ----------------- WARM-UP LOAD (generate CPU/mem) -----------------
      - name: Generate warm-up load (60â€“90s)
        run: |
          set -euo pipefail
          kubectl -n $NS port-forward svc/$SVC 8080:80 >/tmp/app_pf.log 2>&1 &
          echo $! > /tmp/app_pf.pid
          for i in {1..60}; do curl -sf http://127.0.0.1:8080/healthz && break || sleep 1; done
          # ~2000 requests, 20 concurrent -> real CPU/Net usage
          seq 1 2000 | xargs -n1 -P20 -I{} \
            curl -s -m 2 http://127.0.0.1:8080/predict -H 'Content-Type: application/json' \
              --data '{"x": {}}' >/dev/null || true
          kill $(cat /tmp/app_pf.pid) || true

      # ----------------- PROMETHEUS: COLLECT 7 FEATURES -----------------
      - name: Predict failure probability from runtime metrics
        id: predict
        shell: bash
        env:
          THRESHOLD: "0.60"
        run: |
          set -euo pipefail

          # Ensure Prometheus service exists
          kubectl -n "$PROM_NS" get svc "$PROM_SVC" -o name

          # PF Prometheus service (safer trap)
          trap 'p=$(cat /tmp/pf.pid 2>/dev/null || true); [ -n "$p" ] && kill "$p" 2>/dev/null || true; sleep 1; echo "--- pf.log (tail) ---"; tail -n 200 /tmp/pf.log 2>/dev/null || true' EXIT
          kubectl -n "$PROM_NS" port-forward svc/"$PROM_SVC" 9090:9090 >/tmp/pf.log 2>&1 &
          echo $! > /tmp/pf.pid

          # Wait ready
          for i in {1..60}; do curl -sf http://127.0.0.1:9090/-/ready >/dev/null && break || sleep 1; done
          sleep 2

          python - <<'PY'
          import requests, json, os, subprocess

          NS=os.getenv('NS'); DEPLOY=os.getenv('DEPLOY'); THR=float(os.getenv('THRESHOLD',"0.6"))
          PURL='http://127.0.0.1:9090/api/v1/query'

          def q(expr):
              r=requests.get(PURL, params={'query':expr}, timeout=10)
              r.raise_for_status()
              return r.json()

          def val(js):
              try: return float(js['data']['result'][0]['value'][1])
              except: return 0.0

          def first_nonzero(exprs):
              for e in exprs:
                  v = val(q(e))
                  if v > 0: return v
              return 0.0

          join = f'* on(pod,namespace) group_left(owner_kind,owner_name) kube_pod_owner{{namespace="{NS}",owner_kind="Deployment",owner_name="{DEPLOY}"}}'

          # 1) restart_count_last_5m
          restarts = val(q(f'sum(increase(kube_pod_container_status_restarts_total{{namespace="{NS}"}}[5m]) {join})'))

          # 2) cpu_usage_% 
          cpu = val(q(f'sum(rate(container_cpu_usage_seconds_total{{namespace="{NS}",container!="POD",image!=""}}[2m]) {join}) * 100'))

          # 3) memory_usage_bytes
          mem = val(q(f'sum(container_memory_working_set_bytes{{namespace="{NS}",container!="POD",image!=""}} {join})'))

          # 4) ready_replica_ratio
          des = val(q(f'kube_deployment_spec_replicas{{namespace="{NS}",deployment="{DEPLOY}"}}'))
          rdy = val(q(f'kube_deployment_status_ready_replicas{{namespace="{NS}",deployment="{DEPLOY}"}}'))
          ready_ratio = (rdy/des) if des > 0 else 1.0

          # 5) unavailable_replicas
          unavail = val(q(f'kube_deployment_status_replicas_unavailable{{namespace="{NS}",deployment="{DEPLOY}"}}'))

          # 6) network_receive_bytes/s (owner-join first, fallback to namespace)
          net_rx = first_nonzero([
              f'sum(rate(container_network_receive_bytes_total{{namespace="{NS}",pod!=""}}[2m]) {join})',
              f'sum(rate(container_network_receive_bytes_total{{namespace="{NS}"}}[2m]))'
          ])

          # 7) http_5xx_error_rate (common metric names; default 0)
          http5xx = first_nonzero([
              f'sum(rate(http_server_requests_seconds_count{{namespace="{NS}",status=~"5.."}}[2m]))',
              f'sum(rate(flask_http_request_total{{namespace="{NS}",status=~"5.."}}[2m]))',
              f'sum(rate(http_requests_total{{namespace="{NS}",code=~"5.."}}[2m]))'
          ])

          features = {
            "restart_count_last_5m": restarts,
            "cpu_usage_pct": cpu,
            "memory_usage_bytes": mem,
            "ready_replica_ratio": round(ready_ratio, 4),
            "unavailable_replicas": unavail,
            "network_receive_bytes_per_s": net_rx,
            "http_5xx_error_rate": http5xx
          }

          print("features:", json.dumps(features))
          with open("features.json","w") as f: json.dump(features,f)

          # Call model (7-feature predictor)
          prob = float(subprocess.check_output(
              f'python ml_model/predict_failure.py --plain --input-json \'{json.dumps(features)}\'',
              shell=True, text=True).strip())
          print("prob:", prob)

          high = prob > THR

          # Insufficient-signal guard: no CPU & no restarts & healthy replicas
          if cpu == 0.0 and restarts == 0.0 and ready_ratio >= 1.0:
              print("Low signal; forcing low-risk decision for this run.")
              high = False

          with open(os.environ['GITHUB_OUTPUT'],'a') as f:
              f.write(f"fail_prob={prob}\n")
              f.write(f"highrisk={'true' if high else 'false'}\n")
          PY

      - name: Upload features artifact
        uses: actions/upload-artifact@v4
        with:
          name: features-${{ github.run_id }}
          path: features.json

      # ----------------- DECISION -----------------
      - name: Cooldown guard
        id: cooldown
        env:
          COOLDOWN_MIN: "15"
        run: |
          set -euo pipefail
          ts=$(kubectl -n "$NS" get deploy "$DEPLOY" -o jsonpath='{.spec.template.metadata.annotations.kubectl\.kubernetes\.io/restartedAt}' || true)
          if [ -n "${ts:-}" ]; then last=$(date -d "$ts" +%s || echo 0); else last=0; fi
          now=$(date +%s); gap=$(( now - last )); need=$(( ${COOLDOWN_MIN} * 60 ))
          echo "seconds_since_last_restart=$gap"
          if [ "$gap" -lt "$need" ]; then echo "cooldown=true" >> $GITHUB_OUTPUT; else echo "cooldown=false" >> $GITHUB_OUTPUT; fi

      - name: Rollback + alert (risk high AND cooldown passed)
        if: ${{ steps.predict.outputs.highrisk == 'true' && steps.cooldown.outputs.cooldown == 'false' }}
        env:
          SLACK_WEBHOOK_URL: "${{ secrets.SLACK_WEBHOOK_URL }}"
        run: |
          set -euo pipefail
          kubectl -n "$NS" rollout undo deployment/"$DEPLOY"
          kubectl -n "$NS" annotate deployment/"$DEPLOY" kubectl.kubernetes.io/restartedAt="$(date -Is)" --overwrite
          if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
            printf ':rotating_light: *High risk detected* (p=%.2f) â†’ rolled back `%s` in `%s`.\n' "${{ steps.predict.outputs.fail_prob }}" "$DEPLOY" "$NS" \
            | jq -Rs '{text: .}' \
            | curl -X POST -H 'Content-Type: application/json' --data @- "$SLACK_WEBHOOK_URL"
          fi

      - name: Success notice (kept rollout)
        if: ${{ steps.predict.outputs.highrisk != 'true' }}
        env:
          SLACK_WEBHOOK_URL: "${{ secrets.SLACK_WEBHOOK_URL }}"
        run: |
          if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
            printf ':white_check_mark: Rollout *kept*. Risk p=%.2f for `%s` in `%s`.\n' "${{ steps.predict.outputs.fail_prob }}" "$DEPLOY" "$NS" \
            | jq -Rs '{text: .}' \
            | curl -X POST -H 'Content-Type: application/json' --data @- "$SLACK_WEBHOOK_URL"
          fi
